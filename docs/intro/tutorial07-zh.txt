=====================================
编写你的第一个Django应用, 第7部分
=====================================

本教程上接 :doc:`教程 6 </intro/tutorial06-zh>`。我们将继续完成网页投票应用，并着重讲解
如何用 Django 自动生成管理网站，我们曾在 :doc:`教程 2</intro/tutorial02-zh>` 中初次探索过。

自定义管理表单
========================

通过 ``admin.site.register(Question)`` 注册 ``Question`` 后，Django 可以自动构建一个
默认的表单。通常，您想自定义管理表单的外观和功能。你可以在注册时通过配置来实现。

现在先来试试排序表单上的字段。将 ``admin.site.register(Question)`` 所在行替换为：

.. snippet::
    :filename: polls/admin.py

    from django.contrib import admin

    from .models import Question


    class QuestionAdmin(admin.ModelAdmin):
        fields = ['pub_date', 'question_text']

    admin.site.register(Question, QuestionAdmin)

你可以参照上面的形式 —— 创建一个模型管理类，将之作为第二个参数传入 ``admin.site.register()``。
而且这种操作在任何时候都可以进行。

经过上面修改，“Publication date”字段会在“Question”字段之前：

.. image:: _images/admin07.png
   :alt: Fields have been reordered

目前的表单只有两个字段可能看不出什么，但是对于字段很多的表单，设计一个直观合理的排序方式非常重要。

并且在字段数据很多时，还可以将表单分割成多个字段的集合：

.. snippet::
    :filename: polls/admin.py

    from django.contrib import admin

    from .models import Question


    class QuestionAdmin(admin.ModelAdmin):
        fieldsets = [
            (None,               {'fields': ['question_text']}),
            ('Date information', {'fields': ['pub_date']}),
        ]

    admin.site.register(Question, QuestionAdmin)

:attr:`~django.contrib.admin.ModelAdmin.fieldsets` 中的每个元组的第一个元素是字段集合的标题。
它让表单看起来像下面的样子：

.. image:: _images/admin08t.png
   :alt: Form has fieldsets now

添加关联对象
======================

现在我们有了问题管理页面，但是一个 ``Question`` 有多个 ``Choice``，而管理页面并没有显示。

暂时。

现在有两个方法可以解决这个问题：一是就像刚刚 ``Question`` 一样也将 ``Choice`` 注册到管理界面。
这简单:

.. snippet::
    :filename: polls/admin.py

    from django.contrib import admin

    from .models import Choice, Question
    # ...
    admin.site.register(Choice)

现在“Choice”也可以管理页面看到了，其中“Add choice”表单应该类似这样:

.. image:: _images/admin09.png
   :alt: Choice admin page

在这个表单中，“Question”字段是一个选择框，包含了当前数据库中每个问题实例。Django 知道将
:class:`~django.db.models.ForeignKey` 展示为一个 ``<select>`` 框。在我们的例子中，目前
只有一个问题对象存在。

请注意“Add Another”连接到“Question”。每一个包含 ``外键（ForeignKey）` 关系的对象都会有这个。
当你点击“Add Another”时，会弹出一个“Add question”的表单窗口。如果在窗口中添加了问题并点击“Save”，
Django 会将问题保存在数据库中，并动态地把它添加为“Add choice”表单的选项。

但是，实话说，这种将 ``Choice`` 对象添加到系统的方式效率不高。如果在创建 ``Question`` 对象时
直接添加一些 Choice 则会更好。让我们实现它。

删除 ``Choice`` 模型对 ``register()`` 方法的调用。然后，编辑 ``Question`` 的注册代码如下：

.. snippet::
    :filename: polls/admin.py

    from django.contrib import admin

    from .models import Choice, Question


    class ChoiceInline(admin.StackedInline):
        model = Choice
        extra = 3


    class QuestionAdmin(admin.ModelAdmin):
        fieldsets = [
            (None,               {'fields': ['question_text']}),
            ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
        ]
        inlines = [ChoiceInline]

    admin.site.register(Question, QuestionAdmin)

上面的代码告诉 Django：“ ``Choice`` 对象在 ``Question`` 管理页面进行编辑，默认情况，为3个选项
提供了足够的字段。”

载入“Add question”页面来看变成了什么样：

.. image:: _images/admin10t.png
   :alt: Add question page now has choices on it

它的工作原理如下：有3个插槽用于相关的选择 —— 由 ``extra`` 指定 —— 每当你回到已创建的对象的
“Change” 页面，你会再获得三个额外的插槽。

在三个当前插槽的最后，您将找到一个“Add another Choice”的链接。如果您点击它，将会添加一个新插槽。
如果要删除添加的插槽，可以单击添加插槽右上方的 X。请注意，您不能删除原来的三个插槽。
此图片显示所添加的插槽：

.. image:: _images/admin14t.png
   :alt: Additional slot added dynamically

不过还有个小问题，它需要大量的屏幕空间来显示所有的用于输入相关 ``Choice`` 对象的字段。为此，
Django 提供了一个显示内联相关对象的表格方式;你只需要改变 ``ChoiceInline`` 声明如下：

.. snippet::
    :filename: polls/admin.py

    class ChoiceInline(admin.TabularInline):
        #...

With that ``TabularInline`` (instead of ``StackedInline``), the
related objects are displayed in a more compact, table-based format:

.. image:: _images/admin11t.png
   :alt: Add question page now has more compact choices

Note that there is an extra "Delete?" column that allows removing rows added
using the "Add Another Choice" button and rows that have already been saved.

Customize the admin change list
===============================

Now that the Question admin page is looking good, let's make some tweaks to the
"change list" page -- the one that displays all the questions in the system.

Here's what it looks like at this point:

.. image:: _images/admin04t.png
   :alt: Polls change list page

By default, Django displays the ``str()`` of each object. But sometimes it'd be
more helpful if we could display individual fields. To do that, use the
:attr:`~django.contrib.admin.ModelAdmin.list_display` admin option, which is a
tuple of field names to display, as columns, on the change list page for the
object:

.. snippet::
    :filename: polls/admin.py

    class QuestionAdmin(admin.ModelAdmin):
        # ...
        list_display = ('question_text', 'pub_date')

Just for good measure, let's also include the ``was_published_recently()``
method from :doc:`Tutorial 2 </intro/tutorial02>`:

.. snippet::
    :filename: polls/admin.py

    class QuestionAdmin(admin.ModelAdmin):
        # ...
        list_display = ('question_text', 'pub_date', 'was_published_recently')

Now the question change list page looks like this:

.. image:: _images/admin12t.png
   :alt: Polls change list page, updated

You can click on the column headers to sort by those values -- except in the
case of the ``was_published_recently`` header, because sorting by the output
of an arbitrary method is not supported. Also note that the column header for
``was_published_recently`` is, by default, the name of the method (with
underscores replaced with spaces), and that each line contains the string
representation of the output.

You can improve that by giving that method (in :file:`polls/models.py`) a few
attributes, as follows:

.. snippet::
    :filename: polls/models.py

    class Question(models.Model):
        # ...
        def was_published_recently(self):
            now = timezone.now()
            return now - datetime.timedelta(days=1) <= self.pub_date <= now
        was_published_recently.admin_order_field = 'pub_date'
        was_published_recently.boolean = True
        was_published_recently.short_description = 'Published recently?'

For more information on these method properties, see
:attr:`~django.contrib.admin.ModelAdmin.list_display`.

Edit your :file:`polls/admin.py` file again and add an improvement to the
``Question`` change list page: filters using the
:attr:`~django.contrib.admin.ModelAdmin.list_filter`. Add the following line to
``QuestionAdmin``::

    list_filter = ['pub_date']

That adds a "Filter" sidebar that lets people filter the change list by the
``pub_date`` field:

.. image:: _images/admin13t.png
   :alt: Polls change list page, updated

The type of filter displayed depends on the type of field you're filtering on.
Because ``pub_date`` is a :class:`~django.db.models.DateTimeField`, Django
knows to give appropriate filter options: "Any date", "Today", "Past 7 days",
"This month", "This year".

This is shaping up well. Let's add some search capability::

    search_fields = ['question_text']

That adds a search box at the top of the change list. When somebody enters
search terms, Django will search the ``question_text`` field. You can use as many
fields as you'd like -- although because it uses a ``LIKE`` query behind the
scenes, limiting the number of search fields to a reasonable number will make
it easier for your database to do the search.

Now's also a good time to note that change lists give you free pagination. The
default is to display 100 items per page. :attr:`Change list pagination
<django.contrib.admin.ModelAdmin.list_per_page>`, :attr:`search boxes
<django.contrib.admin.ModelAdmin.search_fields>`, :attr:`filters
<django.contrib.admin.ModelAdmin.list_filter>`, :attr:`date-hierarchies
<django.contrib.admin.ModelAdmin.date_hierarchy>`, and
:attr:`column-header-ordering <django.contrib.admin.ModelAdmin.list_display>`
all work together like you think they should.

Customize the admin look and feel
=================================

Clearly, having "Django administration" at the top of each admin page is
ridiculous. It's just placeholder text.

That's easy to change, though, using Django's template system. The Django admin
is powered by Django itself, and its interfaces use Django's own template
system.

.. _ref-customizing-your-projects-templates:

Customizing your *project's* templates
--------------------------------------

Create a ``templates`` directory in your project directory (the one that
contains ``manage.py``). Templates can live anywhere on your filesystem that
Django can access. (Django runs as whatever user your server runs.) However,
keeping your templates within the project is a good convention to follow.

Open your settings file (:file:`mysite/settings.py`, remember) and add a
:setting:`DIRS <TEMPLATES-DIRS>` option in the :setting:`TEMPLATES` setting:

.. snippet::
    :filename: mysite/settings.py

    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [os.path.join(BASE_DIR, 'templates')],
            'APP_DIRS': True,
            'OPTIONS': {
                'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                ],
            },
        },
    ]

:setting:`DIRS <TEMPLATES-DIRS>` is a list of filesystem directories to check
when loading Django templates; it's a search path.

.. admonition:: Organizing templates

    Just like the static files, we *could* have all our templates together, in
    one big templates directory, and it would work perfectly well. However,
    templates that belong to a particular application should be placed in that
    application’s template directory (e.g. ``polls/templates``) rather than the
    project’s (``templates``). We'll discuss in more detail in the
    :doc:`reusable apps tutorial </intro/reusable-apps>` *why* we do this.

Now create a directory called ``admin`` inside ``templates``, and copy the
template ``admin/base_site.html`` from within the default Django admin
template directory in the source code of Django itself
(``django/contrib/admin/templates``) into that directory.

.. admonition:: Where are the Django source files?

    If you have difficulty finding where the Django source files are located
    on your system, run the following command:

    .. code-block:: console

        $ python -c "import django; print(django.__path__)"

Then, just edit the file and replace
``{{ site_header|default:_('Django administration') }}`` (including the curly
braces) with your own site's name as you see fit. You should end up with
a section of code like:

.. code-block:: html+django

    {% block branding %}
    <h1 id="site-name"><a href="{% url 'admin:index' %}">Polls Administration</a></h1>
    {% endblock %}

We use this approach to teach you how to override templates. In an actual
project, you would probably use
the :attr:`django.contrib.admin.AdminSite.site_header` attribute to more easily
make this particular customization.

This template file contains lots of text like ``{% block branding %}``
and ``{{ title }}``. The ``{%`` and ``{{`` tags are part of Django's
template language. When Django renders ``admin/base_site.html``, this
template language will be evaluated to produce the final HTML page, just like
we saw in :doc:`Tutorial 3 </intro/tutorial03>`.

Note that any of Django's default admin templates can be overridden. To
override a template, just do the same thing you did with ``base_site.html`` --
copy it from the default directory into your custom directory, and make
changes.

Customizing your *application's* templates
------------------------------------------

Astute readers will ask: But if :setting:`DIRS <TEMPLATES-DIRS>` was empty by
default, how was Django finding the default admin templates? The answer is
that, since :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` is set to ``True``,
Django automatically looks for a ``templates/`` subdirectory within each
application package, for use as a fallback (don't forget that
``django.contrib.admin`` is an application).

Our poll application is not very complex and doesn't need custom admin
templates. But if it grew more sophisticated and required modification of
Django's standard admin templates for some of its functionality, it would be
more sensible to modify the *application's* templates, rather than those in the
*project*. That way, you could include the polls application in any new project
and be assured that it would find the custom templates it needed.

See the :ref:`template loading documentation <template-loading>` for more
information about how Django finds its templates.

Customize the admin index page
==============================

On a similar note, you might want to customize the look and feel of the Django
admin index page.

By default, it displays all the apps in :setting:`INSTALLED_APPS` that have been
registered with the admin application, in alphabetical order. You may want to
make significant changes to the layout. After all, the index is probably the
most important page of the admin, and it should be easy to use.

The template to customize is ``admin/index.html``. (Do the same as with
``admin/base_site.html`` in the previous section -- copy it from the default
directory to your custom template directory). Edit the file, and you'll see it
uses a template variable called ``app_list``. That variable contains every
installed Django app. Instead of using that, you can hard-code links to
object-specific admin pages in whatever way you think is best.

What's next?
============

The beginner tutorial ends here. In the meantime, you might want to check out
some pointers on :doc:`where to go from here </intro/whatsnext>`.

If you are familiar with Python packaging and interested in learning how to
turn polls into a "reusable app", check out :doc:`Advanced tutorial: How to
write reusable apps</intro/reusable-apps>`.
